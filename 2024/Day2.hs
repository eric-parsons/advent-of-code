import Data.List

-- See https://adventofcode.com/2024/day/2.
-- Assumes valid input. Focus is on brevity and simplicity over optimization.

type Report = [Int]

main = do
  input <- readFile "./Day2.input.txt"
  let reports = parseInput input
  print $ part1 reports
  print $ part2 reports

part1 = checkWith isSafe

part2 = checkWith isSafeWithDampener

checkWith :: (Report -> Bool) -> [Report] -> Int
checkWith predicate = sum . map (fromEnum . predicate)

isSafe :: Report -> Bool
isSafe report = all (\d -> abs d > 0 && abs d <= 3 && signum d == direction) deltas
  where
    -- The deltas between adjacent levels in the report.
    deltas = map (uncurry (-)) . siblings $ report
    direction = signum (head deltas)

isSafeWithDampener :: Report -> Bool
isSafeWithDampener = any isSafe . subReports
  where
    -- Subreports are generated by removing an element from the input.
    subReports [] = []
    subReports (x : xs) = xs : map (x :) (subReports xs)

-- Produces all pairs of adjacent items in a list.
siblings :: [a] -> [(a, a)]
siblings (x1 : x2 : xs) = (x1, x2) : siblings (x2 : xs)
siblings _ = []

parseInput :: String -> [Report]
parseInput = map (map read . words) . lines
